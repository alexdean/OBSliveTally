<!doctype html>
<head>
<meta charset="utf-8">
<title>OBS Tally</title>
<script>
	window.addEventListener("load", init, false);

	var serverip = "127.0.0.1:4444"; //Change the server IP/port here

	var intervalID = 0;
	var socketisOpen = false;
	var studioMode = false;

	// see builsScenesToSources for notes on structure.
	var scenesToSources = {};

	var currentState = {
		"watchedSource": "",    // the source item we are watching. (a camera.)
		"previewScene": "",     // scenes currently in preview.
		"programScenes": [],    // scenes currently in program (live). (can be 2 during transitions.)
		"previewSources": [],   // the names of the visible sources in the current previewScene.
		"programSources": [],   // the names of the visible sources in the current programScenes.
		"streaming": false,     // are we currently streaming?
		"currentDisplay": "off" // what state are we currently showing? "program", "preview", or "off".
	}

	function init() {
		document.getElementById('serverIP').value = serverip;
	}

	function connectToServer() {
		enterFullscreen(document.documentElement);

		serverip = document.getElementById('serverIP').value

		connectWebsocket();
	}

	function connectWebsocket() {
		websocket = new WebSocket("ws://" + serverip);

		websocket.onopen = function(evt) {
			socketisOpen = 1;
			clearInterval(intervalID);
			intervalID = 0;
			requestInitialState();
		};

		websocket.onclose = function(evt) {
			socketisOpen = 0;
			if (!intervalID) {
				intervalID = setInterval(connectWebsocket, 5000);
			}
		};

		websocket.onmessage = function(evt) {
			var data = JSON.parse(evt.data);

			// console.log('onmessage', data);
			if (data.hasOwnProperty("message-id")) {
				handleInitialStateEvent(data)
			} else if (data.hasOwnProperty("update-type")) {
				handleStateChangeEvent(data)
			} else {
				console.log('onmessage unable to handle message.', data);
			}
		};

		websocket.onerror = function(evt) {
			socketisOpen = 0;
			if (!intervalID) {
				intervalID = setInterval(connectWebsocket, 5000);
			}
		};
	}

	function enterFullscreen(element) {
		if (element.requestFullscreen) {
			element.requestFullscreen();
		} else if (element.mozRequestFullScreen) {
			element.mozRequestFullScreen();
		} else if (element.msRequestFullscreen) {
			element.msRequestFullscreen();
		} else if (element.webkitRequestFullscreen) {
			element.webkitRequestFullscreen();
		}
	}

	// send messages to OBS requesting the initial state we need in order to function.
	function requestInitialState() {
		// message-id: we make this up. used to identify response messages which are sent back from OBS.
		// request-type: command to send to OBS
		const commands = [
			{
				"message-id": "get-scene-list",
				// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getscenelist
				"request-type": "GetSceneList"
			},
			{
				"message-id": "get-studio-mode-status",
				// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getstudiomodestatus
				"request-type": "GetStudioModeStatus"
			},
			{
				"message-id": "get-preview-scene",
				// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getpreviewscene
				"request-type": "GetPreviewScene"
			},
			{
				"message-id": "get-streaming-status",
				"request-type": "GetStreamingStatus"
			}
		]

		for (let i = 0; i < commands.length; i++) {
			let payload = commands[i];

			// console.log('sending command', payload);
			if (socketisOpen) {
				websocket.send(JSON.stringify(payload));
			} else {
				console.error('unable to send command. socket not open.', payload);
			}
		}
	}

	function watchSource(sourceName) {
		// console.log("Selected: " + sceneName);
		if (sourceName == "Stream Status") {
			document.getElementById("selectionbox").style.display = "none";
			document.getElementById("settingsbox").style.display = "none";
			document.getElementById("wearelivebox").style.display = "block";
			document.getElementById("wearelivetext").innerHTML = "OFFLINE";
		} else {
			currentState.watchedSource = sourceName;
			document.getElementById("selectedTitleText").innerHTML = sourceName;
			document.getElementById("selectedTitleBox").style.display = "block";
			document.getElementById("selectionbox").style.display = "none";
			document.getElementById("settingsbox").style.display = "none";
		}
		// console.log('after watchSource', currentState);

		setPreviewSources(currentState.previewScene);
		setProgramSources(currentState.programScenes);
		updateDisplay();
	}

	// process responses to requests sent by requestInitialState
	function handleInitialStateEvent(data) {
		const messageId = data["message-id"];

		switch(messageId) {
			case "get-scene-list":
				scenesToSources = buildScenesToSources(data);
				sources = new Set();
				for(scene in scenesToSources) {
					for(source in scenesToSources[scene]) {
						sources.add(source);
					}
				}
				generateSourceSelectionBoxes(Array.from(sources));
				currentState.programScenes = [data['current-scene']];
				break;
			case "get-studio-mode-status":
				studioMode = data["studio-mode"];
				break;
			case "get-preview-scene":
				currentState.previewScene = data['name'];
				break;
			case "get-streaming-status":
				currentState.streaming = data['streaming'];
				break;
			default:
				console.error('handleInitialStateEvent got unknown event.', data);
		}
	}

	// track relationships between sources and scenes.
	// { scene: { source1: true, source2: false} }
	//
	// each sub-object: key is a video source, value is the visibility (boolean)
	// of that source in the scene.
	//
	// expects to receive a data structure from a GetSceneList call
	function buildScenesToSources(data) {
		let output = {};

		data['scenes'].forEach((scene) => {
			scene['sources'].forEach((source) => {
				if (source.type == 'av_capture_input') {
					if (!output[scene.name]) {
						output[scene.name] = {};
					}

					// 'render' is source visibility.
					output[scene.name][source.name] = source.render;
				}
			})
		});

		return output;
	}

	// set currentState values based on incoming websocket messages
	function handleStateChangeEvent(data) {
		const updateType = data["update-type"];
		const scene = data["scene-name"];
		const source = data["item-name"];

		if (!scenesToSources[scene]) {
			scenesToSources[scene] = {};
		}

		let displayNeedsUpdate = true;
		let sceneEdited = false;
		let canUpdateIfInProgram = false;

		switch(updateType) {
			case "PreviewSceneChanged":
				currentState.previewScene = scene;
				setPreviewSources(currentState.previewScene);
				break;
			case "SwitchScenes":
				currentState.programScenes = [scene];
				setProgramSources(currentState.programScenes);
				// only time we can update a currently-live display is when scenes actually change.
				canUpdateIfInProgram = true;
				break;
			case "StreamStarted":
				currentState.streaming = true;
				break;
			case "StreamStopping":
				currentState.streaming = false;
				break;
			case "TransitionBegin":
				currentState.programScenes = [data["to-scene"], data["from-scene"]];
				setProgramSources(currentState.programScenes);
				break;
			case "SceneItemAdded":
				scenesToSources[scene][source] = true; // visible.
				sceneEdited = true;
				break;
			case "SceneItemRemoved":
				if (scenesToSources[scene]) {
					delete scenesToSources[scene][source];
				}
				sceneEdited = true;
				break;
			case "SceneItemVisibilityChanged":
				scenesToSources[scene][source] = data['item-visible'];
				sceneEdited = true
				break;
			default:
				displayNeedsUpdate = false;
		}

		// ok to update preview sources here, but not program sources.
		// (if you edit a scene which is live, OBS won't change the live scene
		// until a transition happens. so doing setProgramSources here would cause
		// the tally light to be out of sync with OBS.)
		if (sceneEdited && (scene == currentState.previewScene)) {
			setPreviewSources(data['scene-name']);
		}

		// only do a display update if we received an event we care about.
		// OBS may send other events as well, which we will disregard.
		if (displayNeedsUpdate) {
			updateDisplay(canUpdateIfInProgram);
		}
	}

	// set currentState.previewSources based on the current preview scene.
	function setPreviewSources(scene) {
		currentState.previewSources = [];

		for (key in scenesToSources[scene]) {
			if (scenesToSources[scene][key]) {
				currentState.previewSources.push(key);
			}
		}
	}

	// set currentState.programSources based on the current program scenes.
	function setProgramSources(scenes) {
		currentState.programSources = [];

		scenes.forEach((scene) => {
			for (key in scenesToSources[scene]) {
				if (scenesToSources[scene][key]) {
					currentState.programSources.push(key);
				}
			}
		});
	}

	// update various HTML elements based on current internal state variables.
	function updateDisplay(canUpdateIfInProgram = true) {
		if (currentState.currentDisplay == 'program' && !canUpdateIfInProgram) {
			return;
		}

		if (currentState.programSources.includes(currentState.watchedSource)) {
			color = "red";
			currentDisplay = "program";
		} else if (currentState.previewSources.includes(currentState.watchedSource) && studioMode) {
			color = "green";
			currentDisplay = "preview";
		} else {
			color = "black";
			currentDisplay = "off";
		}

		currentState.currentDisplay = currentDisplay;

		document.body.style.backgroundColor = color;
		textBackground = (color == "black") ? "white" : "transparent";
		document.getElementById("selectedTitleText").style.backgroundColor = textBackground;

		streamDescription = currentState.streaming ? "LIVE" : "OFFLINE";
		document.getElementById("wearelivetext").innerHTML = streamDescription;
	}

	// build buttons which allow user to select which scene item to watch
	function generateSourceSelectionBoxes(list) {
		content = `<button type='button' onclick='watchSource("Stream Status");'>Stream Status</button><br>`;
		for (i = 0; i < list.length; i++) {
			content += `<button type='button' onclick='watchSource("${list[i]}");'>${list[i]}</button><br>`;
		}
		document.getElementById("selectionbox").innerHTML = content;
	}
</script>

<style>
html {
	height: 100%;
	width: 100%;
}

body {
	height: 100%;
	width: 100%;
	overflow: hidden;
	font-family: monospace;
}

#selectionbox {
	height: 80%;
	width: 80%;
	overflow: scroll;
}

#settingsbox {
	margin: 20px;
}

#selectedTitleBox {
	display: none;
	text-align: center;
}

#selectedTitleText {
	font-weight: bold;
	font-size: 3em;
}

button {
	margin: 8px;
	font-size: 1.5em;
}

input {
	margin: 8px;
	font-size: 1.5em;
}

#wearelivebox {
	display: none;
	text-align: center;
}

#wearelivetext {
	font-weight: bold;
	font-size: 24vw;
}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
</head>
<body>
	<div id="settingsbox">
		<input type="text" id="serverIP">
		<button type="button" onclick="connectToServer();">Connect to Server</button>
	</div>
	<div id="selectionbox"></div>
	<div id="selectedTitleBox">
		<span id="selectedTitleText"></span>
	</div>
	<div id="wearelivebox">
		<span id="wearelivetext"></span>
	</div>
</body>
